{"pages":[{"title":"about","text":"see github.com/overstackme","link":"/about/index.html"},{"title":"categories","text":"","link":"/categories/index.html"},{"title":"tags","text":"","link":"/tags/index.html"}],"posts":[{"title":"Hello OverStack.Me","text":"123456789package mainimport ( &quot;fmt&quot;)func main() { fmt.Println(&quot;Hello OverStack.Me&quot;)}","link":"/202007/hello-world.html"},{"title":"Go程序启动过程","text":"本文基于 go version go1.14.3 darwin/amd64， 不同操作系统启动流程有差异 入口函数Go语言启动时首先需要初始化自己的运行时(runtime), 入口文件为 src/runtime/rt0_darwin_amd64.s 12TEXT _rt0_amd64_darwin(SB),NOSPLIT,$-8 JMP _rt0_amd64(SB) 紧接着，跳转到 src/runtime/asm_amd64.s 中的 _rt0_amd64 函数. 1234TEXT _rt0_amd64(SB),NOSPLIT,$-8 MOVQ 0(SP), DI // argc LEAQ 8(SP), SI // argv JMP runtime·rt0_go(SB) 函数前两行指令将 argc, argc 两个操作系统传入的参数分别存储到了 DI, SI 寄存器中，然后跳转到 runtime·rt0_go 中继续执行. 初始化函数runtime·rt0_go 函数完成了go启动时所需的所有初始化工作 参数初始化1234567// copy arguments forward on an even stackMOVQ DI, AX // argcMOVQ SI, BX // argvSUBQ $(4*8+7), SP // 2args 2autoANDQ $~15, SPMOVQ AX, 16(SP)MOVQ BX, 24(SP) 将存储的argc, argv 参数分别放到 AX, BX 寄存器中，同时减小栈指针且将栈指针进行16位对齐, 最后将参数从寄存器放回栈中. 初始化g0栈信息12345678// create istack out of the given (operating system) stack.// _cgo_init may update stackguard.MOVQ $runtime·g0(SB), DILEAQ (-64*1024+104)(SP), BXMOVQ BX, g_stackguard0(DI)MOVQ BX, g_stackguard1(DI)MOVQ BX, (g_stack+stack_lo)(DI)MOVQ SP, (g_stack+stack_hi)(DI) 此部分程序首先将全局变量 g0 地址存入寄存器 DI 中, 然后在系统线程的栈中为 g0 申请栈空间（64*1024 + 104），初始化g0的栈信息和stackgard. CPU信息相关1234567// find out information about the processor we&apos;re onMOVL $0, AXCPUIDMOVL AX, SICMPL AX, $0JE nocpuinfo(...) 这段代码主要是与CPU相关的查找和初始化 TLS 与 m0 g012345678910LEAQ runtime·m0+m_tls(SB), DICALL runtime·settls(SB)// store through it, to make sure it worksget_tls(BX)MOVQ $0x123, g(BX)MOVQ runtime·m0+m_tls(SB), AXCMPQ AX, $0x123JEQ 2(PC)CALL runtime·abort(SB) 调用 runtime·settls 函数来初始化主线程的TLS，目的是把 m0 与主线程进行关联，并检查是否正常执行. 123456789get_tls(BX)LEAQ runtime·g0(SB), CXMOVQ CX, g(BX) // 将g0地址保存到TLS中LEAQ runtime·m0(SB), AX// save m-&gt;g0 = g0MOVQ CX, m_g0(AX)// save m0 to g0-&gt;mMOVQ AX, g_m(CX) 将TLS地址加载到 BX 寄存器中, 将 g0 的地址保存到TLS中, 也就是 m0.tls[0]=&amp;g0 通过 m0.g0 = &amp;g0, g0.m = &amp;m0 将 m0 与 g0 进行关联, 这样之后在主线程中通过 get_tls 就可以找到 g0, 通过 g0.m 就可以找到 m0 , 这样就实现了 m0 、 g0 与主线程之间的关联. 运行时类型检查1CALL runtime·check(SB) check 函数主要是进行运行时类型检查, 源码在 src/runtime/runtime1.go 中，可自行参阅. 调度器相关1CALL runtime·schedinit(SB) schedinit 函数进行运行时组件的初始化工作，主要包括： 栈、内存分配器、调度器相关初始化 限制最大系统线程数量 初始化执行栈 初始化内存分配器 初始化当前系统线程 垃圾回收器初始化 12345678910111213141516(...)// create a new goroutine to start programMOVQ $runtime·mainPC(SB), AX // entryPUSHQ AXPUSHQ $0 // arg sizeCALL runtime·newproc(SB)POPQ AXPOPQ AX// start this MCALL runtime·mstart(SB)CALL runtime·abort(SB) // mstart should never returnRET(...) 调用 runtime·newproc 函数创建一个新的 goroutine 来启动 runtime.mainPC 所指向的函数 runtime.main. runtime·mstart 启动调度器的循环调度并对刚刚创建的 goroutine 进行调度. runtime.mainruntime.main 函数中会加载用户main函数 main.main, 并在同一个 goroutine 上执行: 12345678910111213141516171819202122232425262728293031323334353637func main() { g := getg() ... // 执行栈最大限制：1GB（64位系统）或者 250MB（32位系统） if sys.PtrSize == 8 { maxstacksize = 1000000000 } else { maxstacksize = 250000000 } ... // 启动系统后台监控（定期垃圾回收、抢占调度等等） if GOARCH != &quot;wasm&quot; { // no threads on wasm yet, so no sysmon systemstack(func() { newm(sysmon, nil) }) } ... // 初始化init // initTask 的实现见 src/cmd/compile/internal/gc/init.go 中 fninit doInit(&amp;main_inittask) // 启动GC清扫工作 gcenable() ... // 执行用户 main 包中的 main 函数 fn := main_main // make an indirect call, as the linker doesn&apos;t know the address of the main package when laying down the runtime fn() ... // 直接退出 exit(0) ...} 流程总结12345678910111213_rt0_amd64_darwin -&gt; _rt0_amd64 -&gt; runtime·rt0_go -&gt; runtime.main -&gt; exit(0) ↓ ↓ runtime·check doInit ↓ ↓ runtime·args gcenable ↓ ↓ runtime·osinit main.main ↓ runtime·schedinit ↓ runtime·newproc ↓ runtime·mstart","link":"/202007/go-program-startup-process.html"}],"tags":[{"name":"golang","slug":"golang","link":"/tags/golang/"},{"name":"helloworld","slug":"helloworld","link":"/tags/helloworld/"}],"categories":[{"name":"编程语言","slug":"编程语言","link":"/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}]}